# coding: utf-8

"""
    Omnuis-API astu specificatioin

    Интеграционный сервис АИС КИС Баланс

    The version of the OpenAPI document: 2.0
    Contact: e-vasilyev@it-serv.ru
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json


from typing import List, Optional
from pydantic import BaseModel, Field, StrictStr, conlist
from openapi_client.models.consumers_inner_usage_points_inner import ConsumersInnerUsagePointsInner
from openapi_client.models.geometry import Geometry

class ConsumersInner(BaseModel):
    """
    ConsumersInner
    """
    action_type: Optional[StrictStr] = Field(None, alias="ActionType")
    consumer_id: Optional[StrictStr] = Field(None, alias="ConsumerId")
    consumer_name: Optional[StrictStr] = Field(None, alias="ConsumerName")
    consumer_type: Optional[StrictStr] = Field(None, alias="ConsumerType")
    contract: Optional[StrictStr] = Field(None, alias="Contract")
    requets_number: Optional[StrictStr] = Field(None, alias="RequetsNumber")
    service_location_id: Optional[StrictStr] = Field(None, alias="ServiceLocationId")
    name: Optional[StrictStr] = Field(None, alias="Name")
    organization_id: Optional[StrictStr] = Field(None, alias="OrganizationId")
    object_status: Optional[StrictStr] = Field(None, alias="ObjectStatus")
    fias_id: Optional[StrictStr] = Field(None, alias="FiasId")
    address: Optional[StrictStr] = Field(None, alias="Address")
    region: Optional[StrictStr] = Field(None, alias="Region")
    district: Optional[StrictStr] = Field(None, alias="District")
    city: Optional[StrictStr] = Field(None, alias="City")
    street: Optional[StrictStr] = Field(None, alias="Street")
    house: Optional[StrictStr] = Field(None, alias="House")
    room: Optional[StrictStr] = Field(None, alias="Room")
    remark: Optional[StrictStr] = Field(None, alias="Remark")
    cadaster: Optional[StrictStr] = Field(None, alias="Cadaster")
    max_power: Optional[StrictStr] = Field(None, alias="MaxPower")
    reliability_category: Optional[StrictStr] = Field(None, alias="ReliabilityCategory")
    phone: Optional[StrictStr] = Field(None, alias="Phone")
    residents_count: Optional[StrictStr] = Field(None, alias="ResidentsCount")
    service_disp_category: Optional[StrictStr] = Field(None, alias="ServiceDispCategory")
    num_of_storeys: Optional[StrictStr] = Field(None, alias="NumOfStoreys")
    stand_by_capacity: Optional[StrictStr] = Field(None, alias="StandByCapacity")
    significance: Optional[StrictStr] = Field(None, alias="Significance")
    service_contingency_catagory: Optional[StrictStr] = Field(None, alias="ServiceContingencyCatagory")
    in_charge_full_name: Optional[StrictStr] = Field(None, alias="InChargeFullName")
    emergency_power_reserve: Optional[StrictStr] = Field(None, alias="EmergencyPowerReserve")
    techno_power_reserve: Optional[StrictStr] = Field(None, alias="TechnoPowerReserve")
    techno_power_reserve_duration: Optional[StrictStr] = Field(None, alias="TechnoPowerReserveDuration")
    geometry: Optional[Geometry] = Field(None, alias="Geometry")
    usage_points: Optional[conlist(ConsumersInnerUsagePointsInner)] = Field(None, alias="UsagePoints")
    __properties = ["ActionType", "ConsumerId", "ConsumerName", "ConsumerType", "Contract", "RequetsNumber", "ServiceLocationId", "Name", "OrganizationId", "ObjectStatus", "FiasId", "Address", "Region", "District", "City", "Street", "House", "Room", "Remark", "Cadaster", "MaxPower", "ReliabilityCategory", "Phone", "ResidentsCount", "ServiceDispCategory", "NumOfStoreys", "StandByCapacity", "Significance", "ServiceContingencyCatagory", "InChargeFullName", "EmergencyPowerReserve", "TechnoPowerReserve", "TechnoPowerReserveDuration", "Geometry", "UsagePoints"]

    class Config:
        """Pydantic configuration"""
        allow_population_by_field_name = True
        validate_assignment = True

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.dict(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> ConsumersInner:
        """Create an instance of ConsumersInner from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self):
        """Returns the dictionary representation of the model using alias"""
        _dict = self.dict(by_alias=True,
                          exclude={
                          },
                          exclude_none=True)
        # override the default output from pydantic by calling `to_dict()` of geometry
        if self.geometry:
            _dict['Geometry'] = self.geometry.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in usage_points (list)
        _items = []
        if self.usage_points:
            for _item in self.usage_points:
                if _item:
                    _items.append(_item.to_dict())
            _dict['UsagePoints'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: dict) -> ConsumersInner:
        """Create an instance of ConsumersInner from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return ConsumersInner.parse_obj(obj)

        _obj = ConsumersInner.parse_obj({
            "action_type": obj.get("ActionType"),
            "consumer_id": obj.get("ConsumerId"),
            "consumer_name": obj.get("ConsumerName"),
            "consumer_type": obj.get("ConsumerType"),
            "contract": obj.get("Contract"),
            "requets_number": obj.get("RequetsNumber"),
            "service_location_id": obj.get("ServiceLocationId"),
            "name": obj.get("Name"),
            "organization_id": obj.get("OrganizationId"),
            "object_status": obj.get("ObjectStatus"),
            "fias_id": obj.get("FiasId"),
            "address": obj.get("Address"),
            "region": obj.get("Region"),
            "district": obj.get("District"),
            "city": obj.get("City"),
            "street": obj.get("Street"),
            "house": obj.get("House"),
            "room": obj.get("Room"),
            "remark": obj.get("Remark"),
            "cadaster": obj.get("Cadaster"),
            "max_power": obj.get("MaxPower"),
            "reliability_category": obj.get("ReliabilityCategory"),
            "phone": obj.get("Phone"),
            "residents_count": obj.get("ResidentsCount"),
            "service_disp_category": obj.get("ServiceDispCategory"),
            "num_of_storeys": obj.get("NumOfStoreys"),
            "stand_by_capacity": obj.get("StandByCapacity"),
            "significance": obj.get("Significance"),
            "service_contingency_catagory": obj.get("ServiceContingencyCatagory"),
            "in_charge_full_name": obj.get("InChargeFullName"),
            "emergency_power_reserve": obj.get("EmergencyPowerReserve"),
            "techno_power_reserve": obj.get("TechnoPowerReserve"),
            "techno_power_reserve_duration": obj.get("TechnoPowerReserveDuration"),
            "geometry": Geometry.from_dict(obj.get("Geometry")) if obj.get("Geometry") is not None else None,
            "usage_points": [ConsumersInnerUsagePointsInner.from_dict(_item) for _item in obj.get("UsagePoints")] if obj.get("UsagePoints") is not None else None
        })
        return _obj


